<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Trivia Admin - Control Panel</title>
  <link rel="stylesheet" href="style-admin.css">
  <style>
    /* Required for scannability and requested hidden scrollbars */
    #admin-leaderboard-list, #teams-list-admin, .rules-scroll {
      overflow-y: auto;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    #admin-leaderboard-list::-webkit-scrollbar, 
    #teams-list-admin::-webkit-scrollbar, 
    .rules-scroll::-webkit-scrollbar {
      display: none;
    }

    #admin-leaderboard-list {
      text-align: left;
      max-height: 300px;
      background: rgba(0,0,0,0.2);
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
    }
    .admin-lb-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid rgba(245, 197, 66, 0.2);
    }
    #admin-podium-preview {
      display: flex;
      justify-content: center;
      align-items: flex-end;
      gap: 15px;
      margin-bottom: 20px;
      padding: 20px;
      background: rgba(255,255,255,0.05);
      border-radius: 10px;
    }
    .admin-podium-slot {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      border: 1px solid var(--gold);
      border-radius: 8px;
      width: 120px;
    }
    .nav-btn.active-tab {
      background: var(--gold);
      color: black;
      font-weight: bold;
    }
  </style>
</head>
<body>

<div id="taskbar" class="taskbar hidden">
  <button id="nav-home" class="nav-btn">Home</button>
  <button id="nav-rules" class="nav-btn">Rules</button>
  <button id="nav-teams" class="nav-btn">Teams</button>
  <button id="nav-r1" class="nav-btn" disabled>Qualifiers</button>
  <button id="nav-r2" class="nav-btn" disabled>Quarterfinals</button>
  <button id="nav-r3" class="nav-btn" disabled>Semifinals</button>
  <button id="nav-r4" class="nav-btn" disabled>Finals</button>
  <button id="nav-leaderboard" class="nav-btn">Leaderboard</button>
  <button id="nav-podium" class="nav-btn">Podium</button>
</div>

<div id="current-tab-indicator" class="tab-indicator">Home</div>

<h1>Trivia Admin Control</h1>

<div id="view-home" class="card">
  <input type="text" id="gameNameInput" placeholder="Enter Game Name" style="font-size: 1.2rem; padding: 10px; margin-bottom: 20px; width: 80%; max-width: 400px; display: block; margin-left: auto; margin-right: auto; text-align: center; border-radius: 5px; border: 1px solid #ccc;">
  <button id="newGameBtn" style="font-size: 1.5rem; padding: 20px;">New Game</button>
</div>

<div id="view-rules" class="card hidden">
  <h2>Game Rules & Scoring</h2>
  <div class="rules-scroll" style="text-align: left; max-height: 400px; padding: 10px;">
    <h3>1. Scoring</h3>
    <ul>
      <li><strong>Response Values:</strong> Correct Answer Reveal Earn 1 to 5 Points Based on Popularity.</li>
      <li><strong>Round-Wise Scores:</strong> Scores will be Reset at the Start of Each Round.</li>
      <li><strong>Round Winner:</strong> Team with Highest Consolidated Score in that Round.</li>
      <li><strong>Game Winner:</strong> Final Round Winner.</li>
    </ul>
    <h3>2. Tournament Progression</h3>
    <ul>
      <li><strong>Qualifiers:</strong> Custom Number of Questions (All the Teams)</li>
      <li><strong>Quarterfinals:</strong> 3 Questions (Top 8 Teams)</li>
      <li><strong>Semifinals:</strong> 5 Questions (Top 4 Teams)</li>
      <li><strong>Finals:</strong> 5 Questions (Top 2 Teams)</li>
    </ul>
    <h3>3. Tie-Breakers</h3>
    <ul>
      <li><strong>Match Ties:</strong> Team with Highest Number of Question Win will be Selected as the Winner if the Total Scores in that Round Remains the Same and if the Question Win is Equal, Team who Won the First Question will be the Winner.</li>
    </ul>
    <h3>4. Match Making</h3>
    <ul>
      <li><strong>Forthcoming Rounds:</strong> Match will be Set Between Consecutive Teams in the Leaderboard of Previous Round.</li>
    </ul>
  </div>
  <button id="btnDisplayRules" class="display-btn">Display Rules to Audience</button>
</div>

<div id="view-teams" class="card hidden">
  <h2>Teams Management</h2>
  <div id="setup-inputs">
    <p>Upload <strong>Teams.csv</strong> (First row must be "Teams")</p>
    <input type="file" id="teamsFile" accept=".csv">
  </div>
  <div id="teams-list-admin" style="margin: 15px 0; text-align: left; max-height: 200px;"></div>
  <button id="btnDisplayTeams" class="display-btn">Display Teams to Audience</button>
</div>

<div id="view-setup" class="card hidden">
  <h2 id="setupTitle">Round Setup</h2>
  
  <div id="q-config-section" style="margin-bottom: 20px;">
    <label>Questions Per Match: </label>
    <input type="number" id="questionsPerMatchInput" value="1" min="1" style="width: 60px; padding: 5px; font-size: 1.2rem; text-align: center;">
  </div>

  <div id="upload-section">
    <label id="qLabel">Upload Questions CSV (Header: Question,Answer,Points)</label><br>
    <input type="file" id="questionsFile" accept=".csv">
  </div>
  <div id="start-section" class="hidden">
    <button id="startRoundBtn" style="background: #22c55e; color: white; font-size: 1.2rem;">Start Round</button>
  </div>
</div>

<div id="view-match" class="card hidden">
  <div id="admin-status" style="background: #f5c542; color: #000; padding: 5px; font-weight: bold; margin-bottom: 10px;">ADMIN PREVIEW - NOT ON AUDIENCE</div>
  <h2 id="matchHeader"></h2>
  <div id="matchQCounter" style="color: #aaa; font-size: 0.9rem; margin-bottom: 5px;"></div>
  <h3 id="questionText"></h3>
  <div id="answers"></div>
  <div class="controls">
    <button id="btnDisplayMatch" class="display-btn" style="background: #3b82f6; color: white;">Display Match to Audience</button>
    <button id="nextQuestionBtn">Next Question / Finish Match</button>
    <button id="endRoundBtn" class="hidden" style="background: #ff4444; color: white;">Complete Round</button>
  </div>
</div>

<div id="view-leaderboard" class="card hidden">
  <h2>Leaderboard Control</h2>
  <div id="admin-leaderboard-list"></div>
  <button id="btnDisplayLeaderboard" class="display-btn">Display Leaderboard to Audience</button>
</div>

<div id="view-podium" class="card hidden">
  <h2>Podium Control</h2>
  <div id="admin-podium-preview"></div>
  <button id="btnDisplayPodium" class="display-btn">Display Podium to Audience</button>
</div>

<script src="sync.js"></script>
<script src="storage.js"></script>
<script>
document.addEventListener("DOMContentLoaded", () => {
  // STATE MANAGEMENT
  let STATE = loadState() || {
    displayMode: "welcome", 
    round: 1, 
    teams: [], 
    pairs: [], 
    matchIndex: 0,
    questionsPool: [], 
    currentQuestion: null, 
    revealed: [], 
    isMatchLive: false, 
    matchWinner: null, 
    matchScores: [0, 0],
    questionsPerMatch: 1,
    currentMatchQuestionNum: 0,
    matchQuestionWins: [0, 0],
    firstQuestionWinnerIdx: null
  };

  const ROUND_NAMES = { 1: "Qualifiers", 2: "Quarterfinals", 3: "Semifinals", 4: "Finals" };
  const ROUND_Q_COUNTS = { 2: 3, 3: 5, 4: 5 };
  const ADVANCEMENT = { 1: 8, 2: 4, 3: 2, 4: 1 };
  const HR = "--------------------------------------------------------------------------------------------------------------\n";

  // --- LOGGING ENGINE (WITH PROMISE QUEUE TO FIX SYNC ISSUES) ---
  let fileHandle = null;
  let logQueue = Promise.resolve();

  function appendToLog(text) {
    if (!fileHandle) return Promise.resolve();
    logQueue = logQueue.then(async () => {
      try {
        const writable = await fileHandle.createWritable({ keepExistingData: true });
        const file = await fileHandle.getFile();
        await writable.seek(file.size);
        await writable.write(text);
        await writable.close();
      } catch (e) { console.warn("Log Append Failed:", e); }
    });
    return logQueue;
  }

  // --- UI NAVIGATION ---
  function resetStatusUI() {
    const status = document.getElementById("admin-status");
    if(status) {
      status.textContent = "ADMIN PREVIEW - NOT ON AUDIENCE";
      status.style.background = "#f5c542";
    }
    STATE.isMatchLive = false;
  }

  const showView = (id, tabName) => {
    document.querySelectorAll('.card').forEach(c => c.classList.add("hidden"));
    document.getElementById(id).classList.remove("hidden");
    document.getElementById("current-tab-indicator").textContent = tabName;
    
    if (id === "view-setup") {
        const hasData = STATE.questionsPool && STATE.questionsPool.length > 0;
        document.getElementById("upload-section").classList.toggle("hidden", hasData);
        document.getElementById("start-section").classList.toggle("hidden", !hasData);
        
        const qInput = document.getElementById("questionsPerMatchInput");
        if (STATE.round === 1) {
            qInput.disabled = false;
        } else {
            qInput.value = ROUND_Q_COUNTS[STATE.round];
            qInput.disabled = true;
        }
    }

    if(id === "view-leaderboard") updateAdminLeaderboard();
    if(id === "view-podium") updateAdminPodium(); 

    document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.classList.toggle('active-tab', btn.textContent === tabName || btn.id.includes(id.split('-')[1]));
    });
  };

  function updateAdminLeaderboard() {
    const list = document.getElementById("admin-leaderboard-list");
    const activeTeams = STATE.teams.filter(t => t.qualified);
    // Sort by Score DESC -> then by Match Win Advantage -> then by Original Order
    const sorted = activeTeams.sort((a,b) => b.score - a.score || (b.isMatchWinner ? 1 : 0) - (a.isMatchWinner ? 1 : 0) || a.order - b.order);
    
    list.innerHTML = sorted.map((t, i) => `
      <div class="admin-lb-item"><span>#${i+1} ${t.name}</span><strong>${t.score} PTS</strong></div>
    `).join("");
  }

  function updateAdminPodium() {
    const preview = document.getElementById("admin-podium-preview");
    // Podium needs ALL teams, ranked by Elimination Round first, then Score/TieBreakers
    const sorted = [...STATE.teams].sort((a,b) => {
        const aRank = a.qualified ? 99 : (a.eliminatedRound || 0);
        const bRank = b.qualified ? 99 : (b.eliminatedRound || 0);
        if (aRank !== bRank) return bRank - aRank;
        return b.score - a.score || (b.isMatchWinner ? 1 : 0) - (a.isMatchWinner ? 1 : 0) || a.order - b.order;
    });

    preview.innerHTML = `
      <div class="admin-podium-slot" style="height: 100px;">
        <div style="font-size: 1.5rem;">ðŸ¥ˆ</div>
        <div style="font-weight: bold;">${sorted[1]?.name || "-"}</div>
        <div style="font-size: 0.8rem;">${sorted[1]?.score || 0} PTS</div>
      </div>
      <div class="admin-podium-slot" style="height: 140px; border-width: 3px;">
        <div style="font-size: 2rem;">ðŸ¥‡</div>
        <div style="font-weight: bold;">${sorted[0]?.name || "-"}</div>
        <div style="font-size: 0.9rem;">${sorted[0]?.score || 0} PTS</div>
      </div>
      <div class="admin-podium-slot" style="height: 80px;">
        <div style="font-size: 1.2rem;">ðŸ¥‰</div>
        <div style="font-weight: bold;">${sorted[2]?.name || "-"}</div>
        <div style="font-size: 0.8rem;">${sorted[2]?.score || 0} PTS</div>
      </div>
    `;
  }

  // --- INITIALIZATION & EVENTS ---
  if (STATE.teams.length > 0) {
    document.getElementById("taskbar").classList.remove("hidden");
    updateTaskbar();
    document.getElementById("teams-list-admin").innerHTML = STATE.teams.map(t => `<div>â€¢ ${t.name}</div>`).join("");
    broadcast(STATE);
  }

  document.getElementById("nav-home").onclick = () => showView("view-home", "Home");
  document.getElementById("nav-rules").onclick = () => showView("view-rules", "Rules");
  document.getElementById("nav-teams").onclick = () => showView("view-teams", "Teams");
  document.getElementById("nav-leaderboard").onclick = () => showView("view-leaderboard", "Leaderboard");
  document.getElementById("nav-podium").onclick = () => showView("view-podium", "Podium");
  
  [1,2,3,4].forEach(r => {
    document.getElementById(`nav-r${r}`).onclick = () => {
      if(STATE.round === r) {
        if (STATE.currentQuestion) showView("view-match", ROUND_NAMES[r]);
        else showView("view-setup", `${ROUND_NAMES[r]} Setup`);
      }
    };
  });

  document.getElementById("btnDisplayRules").onclick = () => { STATE.displayMode = "rules"; broadcast(STATE); saveState(STATE); showView("view-teams", "Teams"); };
  document.getElementById("btnDisplayTeams").onclick = () => { STATE.displayMode = "teams"; broadcast(STATE); saveState(STATE); showView("view-setup", `${ROUND_NAMES[STATE.round]} Setup`); };
  document.getElementById("btnDisplayLeaderboard").onclick = () => { STATE.displayMode = "leaderboard"; broadcast(STATE); saveState(STATE); };
  document.getElementById("btnDisplayPodium").onclick = () => { STATE.displayMode = "podium"; broadcast(STATE); saveState(STATE); };

  // NEW GAME
  document.getElementById("newGameBtn").onclick = async () => {
    if (!window.showSaveFilePicker) return alert("Please use Chrome or Edge for File Access.");
    const gInput = document.getElementById("gameNameInput");
    const gameName = gInput && gInput.value.trim() !== "" ? gInput.value.trim() : "Untitled Game";

    try {
      fileHandle = await window.showSaveFilePicker({
        suggestedName: `${gameName.replace(/\s+/g, '_')}_Log.txt`,
        types: [{ description: 'Text File', accept: {'text/plain': ['.txt']} }]
      });

      window.open("audience.html", "_blank");
      
      clearState();
      STATE = {
        displayMode: "welcome", round: 1, teams: [], pairs: [], matchIndex: 0,
        questionsPool: [], currentQuestion: null, revealed: [], 
        isMatchLive: false, matchWinner: null, matchScores: [0, 0],
        questionsPerMatch: 1, currentMatchQuestionNum: 0, 
        matchQuestionWins: [0, 0], firstQuestionWinnerIdx: null
      };

      showView("view-rules", "Rules");
      document.getElementById("taskbar").classList.remove("hidden");
      document.getElementById("teams-list-admin").innerHTML = "";
      document.getElementById("start-section").classList.add("hidden");
      document.getElementById("upload-section").classList.remove("hidden");
      
      updateTaskbar();
      broadcast(STATE);
      saveState(STATE);

      await appendToLog(`Game: ${gameName}\n\n${HR}\n`);

    } catch (err) { console.error(err); }
  };

  // FILE PARSING
  document.getElementById("teamsFile").onchange = e => {
    const file = e.target.files[0];
    if(!file) return;
    parseCSV(file, rows => {
      if (!rows[0] || rows[0][0].trim() !== "Teams") return alert("First row must be 'Teams'");
      const teamData = rows.slice(1).filter(r => r[0] && r[0].trim() !== "");
      if (teamData.length % 2 !== 0) return alert("Even number of teams required.");
      
      STATE.teams = teamData.map((r, i) => ({ name: r[0].trim(), score: 0, order: i, qualified: true, eliminatedRound: null, isMatchWinner: false }));
      document.getElementById("teams-list-admin").innerHTML = STATE.teams.map(t => `<div>â€¢ ${t.name}</div>`).join("");
      
      let teamLog = `Teams:\nTeam List: ${file.name}\n\n` + STATE.teams.map(t => t.name).join("\n") + `\n\n${HR}\n`;
      appendToLog(teamLog);
      updateTaskbar(); saveState(STATE);
    });
  };

  document.getElementById("questionsFile").onchange = e => {
    const file = e.target.files[0];
    if(!file) return;
    parseCSV(file, rows => {
      const header = rows[0].map(h => h.trim()).join(",");
      if (header !== "Question,Answer,Points") return alert("Header must be Question,Answer,Points");
      const grouped = {};
      rows.slice(1).forEach(r => {
        if (r[0] && r[0].trim() !== "") {
          if (!grouped[r[0]]) grouped[r[0]] = [];
          grouped[r[0]].push({ text: r[1].trim(), points: parseInt(r[2]) || 0 });
        }
      });
      STATE.questionsPool = Object.entries(grouped).map(([q, a]) => ({ question: q, answers: a }));
      
      document.getElementById("upload-section").classList.add("hidden");
      document.getElementById("start-section").classList.remove("hidden");
      
      STATE.qFileName = file.name;
      saveState(STATE);
    });
  };

  // --- START ROUND LOGIC ---
  document.getElementById("startRoundBtn").onclick = async () => {
    const qInput = document.getElementById("questionsPerMatchInput");
    STATE.questionsPerMatch = parseInt(qInput.value) || 1;

    let rLog = `Round: ${ROUND_NAMES[STATE.round]}\n` +
               `No of Questions for this Round per Match: ${STATE.questionsPerMatch}\n\n` +
               `Question List: ${STATE.qFileName || "Unknown"}\n\n\n`;
    await appendToLog(rLog);

    STATE.matchIndex = 0;
    
    // Pairing Active Teams Only
    const activeTeams = STATE.teams
        .filter(t => t.qualified)
        .sort((a,b) => b.score - a.score || (b.isMatchWinner ? 1 : 0) - (a.isMatchWinner ? 1 : 0) || a.order - b.order);

    STATE.pairs = [];
    for(let i=0; i < activeTeams.length; i+=2) {
      if(activeTeams[i+1]) STATE.pairs.push([activeTeams[i], activeTeams[i+1]]);
    }

    // RESET SCORES FOR NEW ROUND (Only for teams still playing!)
    STATE.teams.forEach(t => {
        if (t.qualified) {
            t.score = 0;
            t.isMatchWinner = false; // Reset tie-breaker flag
        }
    });

    STATE.displayMode = "round-start";
    broadcast(STATE);
    prepareMatchStart();
  };

  // --- MATCH LOGIC ---
  function prepareMatchStart() {
    STATE.currentMatchQuestionNum = 0;
    STATE.matchScores = [0, 0]; 
    STATE.matchQuestionWins = [0, 0];
    STATE.firstQuestionWinnerIdx = null;
    STATE.matchWinner = null;
    
    loadNextQuestionForMatch();
  }

  function loadNextQuestionForMatch() {
    resetStatusUI(); 
    if (STATE.questionsPool.length === 0) return alert("No questions left in pool!");
    
    STATE.currentMatchQuestionNum++;
    STATE.currentQuestion = STATE.questionsPool.splice(Math.floor(Math.random() * STATE.questionsPool.length), 1)[0];
    STATE.revealed = [];
    
    renderMatchUI();
    showView("view-match", ROUND_NAMES[STATE.round]);
    
    document.getElementById("nextQuestionBtn").classList.add("hidden");
    document.getElementById("endRoundBtn").classList.add("hidden");
    document.getElementById("matchQCounter").textContent = `Question No: ${STATE.currentMatchQuestionNum}/${STATE.questionsPerMatch}`;
    
    if (STATE.currentMatchQuestionNum === 1) {
        const pair = STATE.pairs[STATE.matchIndex];
        appendToLog(`Match: ${pair[0].name} Vs ${pair[1].name}\n\n\n`);
    }

    appendToLog(`Question No: ${STATE.currentMatchQuestionNum}/${STATE.questionsPerMatch}\nQuestion: ${STATE.currentQuestion.question}\n\n`);
    saveState(STATE);
  }

  function renderMatchUI() {
    const pair = STATE.pairs[STATE.matchIndex];
    document.getElementById("matchHeader").textContent = `${pair[0].name} vs ${pair[1].name}`;
    document.getElementById("questionText").textContent = STATE.currentQuestion.question;
    document.getElementById("answers").innerHTML = STATE.currentQuestion.answers.map((ans, i) => `
      <div class="answer-row">
        <span>${ans.text} (${ans.points})</span>
        <div class="btn-group">
          <button onclick="award(${i}, 0)">+ ${pair[0].name}</button>
          <button onclick="award(${i}, 1)">+ ${pair[1].name}</button>
          <button style="background: #94a3b8" onclick="award(${i}, null)">Empty Reveal</button>
        </div>
      </div>
    `).join("");
  }

  window.award = (ansIdx, teamIdxInPair) => {
    if (!STATE.isMatchLive) return alert("Click 'Display Match to Audience' first!");
    if (STATE.revealed.find(r => r.idx === ansIdx)) return;
    
    const ans = STATE.currentQuestion.answers[ansIdx];
    const pair = STATE.pairs[STATE.matchIndex];
    let winnerName = (teamIdxInPair !== null) ? pair[teamIdxInPair].name : "Empty Reveal";
    
    if (teamIdxInPair !== null) {
      STATE.teams.find(t => t.name === winnerName).score += ans.points;
      STATE.matchScores[teamIdxInPair] += ans.points;
    }
    
    STATE.revealed.push({ idx: ansIdx, winnerName: winnerName });
    appendToLog(`${ansIdx + 1}) ${ans.text} : ${winnerName} -> ${ans.points}\n`);

    broadcast(STATE); saveState(STATE);

    if (STATE.revealed.length === STATE.currentQuestion.answers.length) {
        let qScores = [0, 0];
        STATE.revealed.forEach(r => {
             const a = STATE.currentQuestion.answers[r.idx];
             if(pair[0].name === r.winnerName) qScores[0] += a.points;
             if(pair[1].name === r.winnerName) qScores[1] += a.points;
        });

        if (qScores[0] > qScores[1]) {
            STATE.matchQuestionWins[0]++;
            if(STATE.currentMatchQuestionNum === 1) STATE.firstQuestionWinnerIdx = 0;
        } else if (qScores[1] > qScores[0]) {
            STATE.matchQuestionWins[1]++;
            if(STATE.currentMatchQuestionNum === 1) STATE.firstQuestionWinnerIdx = 1;
        }

        const nextBtn = document.getElementById("nextQuestionBtn");
        nextBtn.classList.remove("hidden");
        
        if (STATE.currentMatchQuestionNum < STATE.questionsPerMatch) {
            nextBtn.textContent = "Next Question";
            nextBtn.onclick = () => loadNextQuestionForMatch();
        } else {
            nextBtn.textContent = "Finish Match";
            nextBtn.onclick = () => finishMatch();
        }
        appendToLog(`\n`); 
    }
  };

  document.getElementById("btnDisplayMatch").onclick = () => { 
    STATE.displayMode = "match"; STATE.isMatchLive = true; 
    document.getElementById("admin-status").textContent = "LIVE ON AUDIENCE";
    document.getElementById("admin-status").style.background = "#22c55e";
    broadcast(STATE); saveState(STATE);
  };

  async function finishMatch() {
      const pair = STATE.pairs[STATE.matchIndex];
      
      // Determine Winner
      if (STATE.matchScores[0] > STATE.matchScores[1]) STATE.matchWinner = pair[0].name;
      else if (STATE.matchScores[1] > STATE.matchScores[0]) STATE.matchWinner = pair[1].name;
      else {
          if (STATE.matchQuestionWins[0] > STATE.matchQuestionWins[1]) STATE.matchWinner = pair[0].name;
          else if (STATE.matchQuestionWins[1] > STATE.matchQuestionWins[0]) STATE.matchWinner = pair[1].name;
          else {
              if (STATE.firstQuestionWinnerIdx === 0) STATE.matchWinner = pair[0].name;
              else if (STATE.firstQuestionWinnerIdx === 1) STATE.matchWinner = pair[1].name;
              else STATE.matchWinner = "DRAW (Coin Toss)";
          }
      }

      const winnerObj = STATE.teams.find(t => t.name === STATE.matchWinner);
      if (winnerObj) winnerObj.isMatchWinner = true; // Mark Match Winner for Leaderboard Tie-breakers

      const winnerTotal = winnerObj ? winnerObj.score : 0;

      let resultLog = `\n${pair[0].name} => ${STATE.matchScores[0]} Points\n` + 
                      `${pair[1].name} => ${STATE.matchScores[1]} Points\n` + 
                      `Winner: ${STATE.matchWinner} => ${winnerTotal} Points\n\n${HR}\n`;
      await appendToLog(resultLog);

      STATE.displayMode = "match-winner";
      broadcast(STATE); saveState(STATE);

      setTimeout(() => {
          if (STATE.matchIndex < STATE.pairs.length - 1) {
              STATE.matchIndex++;
              STATE.displayMode = "leaderboard";
              broadcast(STATE);
              prepareMatchStart();
          } else {
              alert("All Matches Complete for this Round!");
              document.getElementById("endRoundBtn").classList.remove("hidden");
              document.getElementById("nextQuestionBtn").classList.add("hidden");
          }
      }, 5000);
  }

  document.getElementById("endRoundBtn").onclick = async () => {
    resetStatusUI();
    
    const limit = ADVANCEMENT[STATE.round];
    const activeTeams = STATE.teams.filter(t => t.qualified);
    const sorted = activeTeams.sort((a,b) => b.score - a.score || (b.isMatchWinner ? 1 : 0) - (a.isMatchWinner ? 1 : 0) || a.order - b.order);
    
    // Mark Newly Eliminated Teams
    sorted.slice(limit).forEach(t => {
        const team = STATE.teams.find(orig => orig.name === t.name);
        if (team) {
            team.qualified = false;
            team.eliminatedRound = STATE.round; // Remember when they lost to score 3rd place!
        }
    });

    let lbLog = `${ROUND_NAMES[STATE.round]} Over\n\n${HR}\nLeaderBoard:\n`;
    sorted.forEach((t, i) => {
        lbLog += `${i+1}) ${t.name} : ${t.score} => (${t.qualified ? 'Selected' : 'Eliminated'})\n`;
    });
    lbLog += `\n${HR}\n`;
    await appendToLog(lbLog);

    STATE.displayMode = "round-complete";
    broadcast(STATE); saveState(STATE);

    document.getElementById("upload-section").classList.remove("hidden");
    document.getElementById("start-section").classList.add("hidden");
    document.getElementById("questionsFile").value = ""; 

    setTimeout(async () => {
        if (STATE.round < 4) {
            STATE.round++; 
            STATE.currentQuestion = null; 
            STATE.questionsPool = [];
            showView("view-leaderboard", "Leaderboard");
        } else {
            showView("view-podium", "Podium");
            const podiumSorted = [...STATE.teams].sort((a,b) => {
                const aRank = a.qualified ? 99 : (a.eliminatedRound || 0);
                const bRank = b.qualified ? 99 : (b.eliminatedRound || 0);
                if (aRank !== bRank) return bRank - aRank;
                return b.score - a.score || (b.isMatchWinner ? 1 : 0) - (a.isMatchWinner ? 1 : 0) || a.order - b.order;
            });
            let pod = `Game Winners\nFirst: ${podiumSorted[0].name} : ${podiumSorted[0].score} Points\nSecond: ${podiumSorted[1].name} : ${podiumSorted[1].score} Points\nThird: ${podiumSorted[2].name} : ${podiumSorted[2].score} Points\n\n${HR}\n`;
            await appendToLog(pod);
        }
        updateTaskbar(); saveState(STATE);
    }, 4000);
  };

  function updateTaskbar() {
    [1,2,3,4].forEach(r => {
      const btn = document.getElementById(`nav-r${r}`);
      btn.disabled = (STATE.round !== r);
      btn.classList.toggle("active-tab", STATE.round === r);
    });
  }

  function parseCSV(file, cb) {
    const r = new FileReader();
    r.onload = () => cb(r.result.trim().split("\n").map(l => l.split(",").map(c => c ? c.trim() : "")));
    r.readAsText(file);
  }
});
</script>

</body>
</html>